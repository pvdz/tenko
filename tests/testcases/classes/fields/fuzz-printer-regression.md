# Tenko parser test case

- Path: tests/testcases/classes/fields/fuzz-printer-regression.md

> :: classes : fields
>
> ::> fuzz-printer-regression
>
> By fuzzer; input broke printer [diff-fail]

## Input

`````js
// This file was procedurally generated from the following sources:
// - src/class-elements/computed-names.case
// - src/class-elements/productions/cls-expr-after-same-line-gen.template
/*---
description: Computed property names (field definitions after a generator in the same line)
esid: prod-FieldDefinition
features: [class-fields-public, computed-property-names, generators, class]
flags: [generated]
includes: [propertyHelper.js]
info: |
    ClassElement:
      ...
      FieldDefinition ;
    FieldDefinition:
      ClassElementName Initializer_opt
    ClassElementName:
      PropertyName
---*/
var x = "b";
var C = class {
  *m() { return 42; } [x] = 42; [10] = "meep"; ["not initialized"];

}
var c = new C();
assert.sameValue(c.m().next().value, 42);
assert.sameValue(Object.hasOwnProperty.call(c, "m"), false);
assert.sameValue(c.m, C.prototype.m);
verifyProperty(C.prototype, "m", {
  enumerable: false,
  configurable: true,
  writable: true,
});
assert.sameValue(Object.hasOwnProperty.call(C.prototype, "b"), false);
assert.sameValue(Object.hasOwnProperty.call(C, "b"), false);
verifyProperty(c, "b", {
  value: 42,
  enumerable: true,
  writable: true,
  configurable: true
});
assert.sameValue(Object.hasOwnProperty.call(C.prototype, "x"), false);
assert.sameValue(Object.hasOwnProperty.call(C, "x"), false);
assert.sameValue(Object.hasOwnProperty.call(c, "x"), false);
assert.sameValue(Object.hasOwnProperty.call(C.prototype, "10"), false);
assert.sameValue(Object.hasOwnProperty.call(C, "10"), false);
verifyProperty(c, "10", {
  value: "meep",
  enumerable: true,
  writable: true,
  configurable: true
});
assert.sameValue(Object.hasOwnProperty.call(C.prototype, "not initialized"), false);
assert.sameValue(Object.hasOwnProperty.call(C, "not initialized"), false);
verifyProperty(c, "not initialized", {
  value: undefined,
  enumerable: true,
  writable: true,
  configurable: true
});
`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in five parsing modes: sloppy, sloppy+annexb, strict script, module, module+annexb.

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
throws: Parser error!
  Expected to parse an opening paren, found `=`

start@16:2, error@21:26
╔═══╦══════════════════
 16 ║   ClassElementName:
 17 ║       PropertyName
 18 ║ ---*/
 19 ║ var x = "b";
 20 ║ var C = class {
 21 ║   *m() { return 42; } [x] = 42; [10] = "meep"; ["not initialized"];
    ║                           ^------- error
 22 ║
 23 ║ }
 24 ║ var c = new C();
 25 ║ assert.sameValue(c.m().next().value, 42
╚═══╩══════════════════

`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Sloppy mode with AnnexB

Parsed with script goal with AnnexB rules enabled and as if the code did not start with strict mode header.

_Output same as sloppy mode._

### Module goal with AnnexB

Parsed with the module goal with AnnexB rules enabled.

_Output same as sloppy mode._
