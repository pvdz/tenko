# Tenko parser test cases

- Path: zeparser3/tests/testcases/let_declaration/binding_generic/rest/invalid_obj_rest/autogen.md

> :: let declaration : binding generic : rest
>
> ::> invalid obj rest
>
> Note: object rest can only be on an ident (this can be any pattern in assignment destructuring)

These cases are automatically extrapolated and written to their own file.
Each case is applied to each test by simply replacing `#` with the actual case.

## Input

### Cases

> `````js
> let {...obj1,} = foo
> `````

> `````js
> let {...obj1,a} = foo
> `````

> `````js
> let {...obj1,...obj2} = foo
> `````

> `````js
> let {...(obj)} = foo
> `````

> `````js
> let {...(a,b)} = foo
> `````

> `````js
> let {...{a,b}} = foo
> `````

> `````js
> let {...[a,b]} = foo
> `````

### Templates

#### case

`````js
#
`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in five parsing modes: sloppy, sloppy+annexb, strict script, module, module+annexb.

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
throws: Lexer error!
    Private identifier expected after #

start@1:0, error@1:0
╔══╦════════════════
 1 ║ #
   ║ ^------- error
╚══╩════════════════

`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Sloppy mode with AnnexB

Parsed with script goal with AnnexB rules enabled and as if the code did not start with strict mode header.

_Output same as sloppy mode._

### Module goal with AnnexB

Parsed with the module goal with AnnexB rules enabled.

_Output same as sloppy mode._
